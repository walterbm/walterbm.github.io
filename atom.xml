<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[WBM Blog]]></title>
  <link href="http://walterbm.github.io/atom.xml" rel="self"/>
  <link href="http://walterbm.github.io/"/>
  <updated>2015-09-01T23:41:18-04:00</updated>
  <id>http://walterbm.github.io/</id>
  <author>
    <name><![CDATA[Walter Beller-Morales]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Named Scopes in Rails]]></title>
    <link href="http://walterbm.github.io/blog/2015/08/05/named-scopes-in-rails/"/>
    <updated>2015-08-05T01:12:11-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/08/05/named-scopes-in-rails</id>
    <content type="html"><![CDATA[<p>One of the beautiful things about Ruby is its inherent commitment to flexibility. In Ruby there&rsquo;s always more than one solution to a problem. Even in the <em>convention over configuration</em> world of Rails there are still a few enclaves of flexibility.</p>

<p>Named scopes are a great example of this inherent flexibility but they can also be disorienting for young-developers like myself who are not yet familiar with all the tools Rails makes available.</p>

<h3>What Are Scopes?</h3>

<p>Scopes are Active Record macros for Model class-methods. Essentially a scope builds a class-method for the specific Model when the Rails server is initiated. Let&rsquo;s build a simple query to select all the red cars in our database using both a class-method and a scope.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">red</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">color</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Car</span><span class="o">.</span><span class="n">red</span> <span class="c1">#=&gt; ActiveRecord::Relation representing all red Cars</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">scope</span> <span class="ss">:red</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">&quot;month &gt;= ?&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">ago</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Car</span><span class="o">.</span><span class="n">red</span> <span class="c1">#=&gt; ActiveRecord::Relation representing all red Cars</span>
</span></code></pre></td></tr></table></div></figure>


<p>Both the class-method <code>red</code> and the named scope method <code>red</code> are identical in function.</p>

<p>However, scopes are convented from macros to class-methods when the Model class is interpreted (usually when the Rails server is initiated). When the class is interpreted the scope condition is immediately evaluated and statically set in the class-method produced by the scope.</p>

<p>This behavior is not really relevant when the scope condition is already static (like checking the color in the example above) but will cause problems for dynamic conditions. While Rails 4 has default warnings to catch this behavior, exploring this quirk can help us better understand Rails initiation process. To illustrate let&rsquo;s build a scope to query our Car database for cars made in the last two months.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">scope</span> <span class="ss">:red</span><span class="p">,</span> <span class="n">where</span><span class="p">(</span><span class="s2">&quot;month &gt;= ?&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">.</span><span class="n">months</span><span class="o">.</span><span class="n">ago</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will trigger some warnings but should work&hellip;but only relative to the time period when the Rails server was initiated. So if the server was initiated in March then <code>2.months.ago</code> would be converted into January. The value would be statically set in the class-method produced by the scope. In effect, the query would be searching for cars made since January rather than the cars made in the last two months.</p>

<p>To solve this problem the scope condition can be wrapped in a <code>proc</code> or a <code>lambda</code>. A common pattern is to wrap the condition using the &lsquo;stabby&rsquo; lambda syntax.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>  <span class="n">scope</span> <span class="ss">:red</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">&quot;month &gt;= ?&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">ago</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This ensure that the condition is evaluated every time the class-method produced by the scope is called. Rails 4 has made this pattern madnatory regardless of conditional used in the scope.</p>

<h3>Why Use Scopes?</h3>

<p>Ultimately the choice between using scopes or class-methods is stylistic rather than functional. Scopes help reduce the line-length of your Models but the exact same functionality can be implemented using traditional class-methods.</p>

<p>Scopes are best used for simple queries which will be used repeatedly while class-methods are best used for more complex queries.</p>

<h3>References &amp; Notes</h3>

<ul>
<li>[1] <a href="http://guides.rubyonrails.org/active_record_querying.html#scopes">Offical Ruby on Rails documentation for Active Record scopes</a></li>
<li>[2] <a href="http://railscasts.com/episodes/108-named-scope">Slightly outdated (using Rails 2) Railscast on named scopes</a></li>
<li>[3] <a href="http://blog.plataformatec.com.br/2013/02/active-record-scopes-vs-class-methods/">An excellent and more comprehensive post on scopes by Plataformatec (the Brazilian company behind the devise gem and the Elixr language)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Duck typing in Ruby]]></title>
    <link href="http://walterbm.github.io/blog/2015/07/21/duck-typing-in-ruby/"/>
    <updated>2015-07-21T21:37:50-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/07/21/duck-typing-in-ruby</id>
    <content type="html"><![CDATA[<h2>&ldquo;If is says its a duck&hellip;well that&rsquo;s good enough for me.&rdquo;</h2>

<p>If you&rsquo;ve been working with any sort of dynamic programming language like Ruby, JavaScript, Python, etc. (or hanging around with some strange people) you might have heard the phrase: <em>&ldquo;duck typing.&rdquo;</em> So what does this esoteric jargon mean?</p>

<p>Well, in short, &ldquo;duck typing&rdquo; is the idea that the behavior or capabilities of an object should not be determined by the object&rsquo;s type but rather by the object&rsquo;s public interface.</p>

<p>That&rsquo;s it.</p>

<p><img class="center" src="http://walterbm.github.io/images/duck.jpg" title="Quack!" ></p>

<p>Still reading? Alright, I&rsquo;ll elaborate.</p>

<h2>Why call it &ldquo;duck typing&rdquo;?</h2>

<p>&ldquo;Duck typing&rdquo; was coined by Alex Martelli during the delirious months after Y2K as an attempt to explain the fuzzy behavior of dynamic typing.[1] Compared to the concrete type certainty of C++ and Java, dynamic typing meant that programmers never quite knew the exact <em>type</em> of the objects they were using. In response, early converts to dynamic languages attempted to force static typing by incessantly checking an object&rsquo;s type. Martelli used a simple analogy to dissuade this behavior:</p>

<blockquote><p>Don&rsquo;t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what subset of duck-like behavior you need to play your language-games with.</p></blockquote>

<h2>Examples of &ldquo;duck typing&rdquo; in Ruby</h2>

<p>In Ruby <em>everything</em> is an Object and nothing is statically typed. Which is to say, in Ruby the <em>type</em> of a variable or a method is never declared but rather defined through behavior. This inherent flexibility is perfect for &ldquo;duck typing.&rdquo;</p>

<p>Let&rsquo;s create two classes, <code>Duck</code> and <code>Dilophosaurus</code>, to illustrate how &ldquo;duck typing&rdquo; works in Ruby. We will give the <code>Duck</code> class instance methods for <code>walk</code> and <code>quack</code>. The <code>Dilophosaurus</code> class will also get a <code>walk</code> method but it will <code>kill</code> instead of quack.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Duck</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">walk</span>
</span><span class='line'>    <span class="s2">&quot;walks&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">quack</span>
</span><span class='line'>    <span class="s2">&quot;quacks&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Dilophosaurus</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">walk</span>
</span><span class='line'>    <span class="s2">&quot;walks&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">kill</span>
</span><span class='line'>    <span class="s2">&quot;bite!&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Obviously, a duck and a dilophosaurus are nothing alike (you&rsquo;ll never convince me that dinosaurs are birds) so Ruby couldn&rsquo;t possibly confuse an instance of a <code>Duck</code> with an instance of a <code>Dilophosaurus</code>. Right?</p>

<p>Let&rsquo;s try it! We can build a small <code>is_a_duck?</code> method to give us an idea of how Ruby is treating the two instances.</p>

<p>In this first example the <code>is_a_duck?</code> method simply checks whether the object passed as an argument responds to the <code>walk</code> method. If it responds to the methods a <code>Duck</code> instance would respond to then it&rsquo;s a <code>Duck</code>. <strong>If it walks like a duck&hellip;</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">daffy</span> <span class="o">=</span> <span class="no">Duck</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">dino</span> <span class="o">=</span> <span class="no">Dilophosaurus</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">is_a_duck?</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
</span><span class='line'>  <span class="n">animal</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:walk</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">daffy</span><span class="p">)</span>      <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">dino</span><span class="p">)</span>       <span class="c1">#=&gt; true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since both <code>Duck</code> and <code>Dilophosaurus</code> share the public method <code>walk</code> Ruby simply doesn&rsquo;t care that the instances come from different classes. For the purposes of <code>walk</code> both objects can be treated as if they were the same type.</p>

<p>That&rsquo;s the great power of &ldquo;duck typing. &rdquo; The method <code>is_a_duck?</code> does not care about the class of its argument and is flexible enough to be used with multiple types of objects as long as that object responds to <code>walk</code>.</p>

<p>But this example is explicitly checking whether an object responds to a method and this seems overly contrived. If Ruby can handle dynamic typing so easily why not try a more realistic example.</p>

<p>Let&rsquo;s modify the <code>is_a_duck?</code> method to call the <code>quack</code> method on whatever is passed as an argument. <strong>If it quacks like a duck&hellip;</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">is_a_duck?</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">animal</span><span class="o">.</span><span class="n">quack</span>
</span><span class='line'>    <span class="kp">true</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">daffy</span><span class="p">)</span>       <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">dino</span><span class="p">)</span>        <span class="c1">#=&gt; undefined method `quack&#39; for #&lt;Dilophosaurus&gt; (NoMethodError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Not good. Since the <code>Dilophosaurus</code> instance does not have a public method <code>quack</code> Ruby throws-up in disgust and the program breaks. A dinosaur cannot quack and a <code>Dilophosaurus</code> instance should not be treated like a <code>Duck</code>.</p>

<p>This might seem like a trivial example but imagine the <code>is_a_duck?</code> method is buried under thousands of lines of code and executed by a Kafkaesque chain of callback methods. In this nightmare scenario it might be impossible to ensure the <code>is_a_duck?</code> method is never passed a <code>Dilophosaurus</code> instance or any other object that does not respond to <code>quack</code>.</p>

<p>That&rsquo;s the danger of &ldquo;duck typing&rdquo;. If you treat all objects with the same public methods as being of the same type you&rsquo;ll invariably allow an object to pass through that could crash your whole program.</p>

<p>For one last example let&rsquo;s see how we could simulate static typing in Ruby by explicitly checking the argument&rsquo;s class to make sure it is a <code>Duck</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">is_a_duck?</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">animal</span><span class="o">.</span><span class="n">instance_of?</span><span class="p">(</span><span class="no">Duck</span><span class="p">)</span>
</span><span class='line'>    <span class="s2">&quot;it </span><span class="si">#{</span><span class="n">animal</span><span class="o">.</span><span class="n">walk</span><span class="si">}</span><span class="s2"> like a duck and </span><span class="si">#{</span><span class="n">animal</span><span class="o">.</span><span class="n">quack</span><span class="si">}</span><span class="s2"> like a duck because we made sure it was a </span><span class="si">#{</span><span class="n">animal</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="kp">false</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">daffy</span><span class="p">)</span>       <span class="c1">#=&gt; &quot;it walks like a duck and quacks like a duck because we made sure it was a Duck&quot;</span>
</span><span class='line'><span class="n">is_a_duck?</span><span class="p">(</span><span class="n">dino</span><span class="p">)</span>        <span class="c1">#=&gt; false</span>
</span></code></pre></td></tr></table></div></figure>


<p>No confusion here. But this type-certainty comes at a cost. The <code>is_a_duck?</code> method will never work with anything other than <code>Duck</code> instances and has now become completely inflexible (not to mention unnecessarily verbose). This kind of rigidity goes against Ruby&rsquo;s core philosophy and is probably best reserved for static typed languages.</p>

<h2>Why should I care about &ldquo;duck typing&rdquo;</h2>

<p>When used cautiously &ldquo;duck typing&rdquo; can be an extremely elegant design technique. Allowing the logic of your code to rely solely on public interfaces rather than the underlying objects grants your application an immense flexibility to grow and adapt over time.</p>

<p>But don&rsquo;t take my word for it. Follow the advice of the always eloquent Sandi Metz:</p>

<blockquote><p>If every object trusts all others to be what it expects at any given moment, and any object can be any kind of thing, the design possibilities are infinite. These possibilities can be used to create flexible designs that are marvels of structured creativity or, alternatively, to construct terrifying designs that are incomprehensibly chaotic.[2]</p></blockquote>

<h3>References &amp; Notes</h3>

<ul>
<li>[1] <a href="https://groups.google.com/forum/?hl=en#!msg/comp.lang.python/CCs2oJdyuzc/NYjla5HKMOIJ">The October 2000 Google Group discussion where Alex Martelli first released &ldquo;duck-typing&rdquo; into the wild</a></li>
<li>[2] <a href="http://www.poodr.com/">Please read Sandi Metz&rsquo;s Practical Object-Oriented Design in Ruby (especially Chapter 5). Sandi Metz&rsquo;s guidance is mandatory reading for anyone designing an object-oriented application</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&amp;Blocks, &amp;Procs, &amp;Lambdas]]></title>
    <link href="http://walterbm.github.io/blog/2015/07/09/blocks-procs-and-lambdas/"/>
    <updated>2015-07-09T04:31:49-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/07/09/blocks-procs-and-lambdas</id>
    <content type="html"><![CDATA[<p>Closures are technique for implementing lexical scoping.[1] They encapsulate functions, variables, and an environment. Blocks, Procs, and Lambdas are all examples of closures in Ruby.</p>

<h2>Blocks</h2>

<p>Blocks are chunks of code that respond to a <code>yield</code> statement. You&rsquo;ve definitely used Blocks before. Probably used one this morning. Most enumerator methods, like <code>each</code>,<code>map</code>, and <code>reduce</code>, accept a block as an argument.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="s1">&#39;Rocko&#39;</span><span class="p">,</span><span class="s1">&#39;Spunky&#39;</span><span class="p">,</span><span class="s1">&#39;Heffer&#39;</span><span class="p">,</span><span class="s1">&#39;Filburt&#39;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="nb">name</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#=&gt; Rocko!</span>
</span><span class='line'><span class="c1">#=&gt; Spunky!</span>
</span><span class='line'><span class="c1">#=&gt; Heffer!</span>
</span><span class='line'><span class="c1">#=&gt; Filburt!</span>
</span></code></pre></td></tr></table></div></figure>


<p>All the code between the <code>do</code> and <code>end</code> sandwich is a Block. Behind the scenes the <code>each</code> enumerator method is using a <code>yield</code> statement to pass the string into the Block we provided. If you&rsquo;ve ever seen the error: <code>no block given (yield) (LocalJumpError)</code> you&rsquo;ve encountered a method that expected a block but did not receive it. A monkey-patched example reveals the internals of how methods that expect a Block work:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Array</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">monkey_each</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">string</span><span class="o">|</span>
</span><span class='line'>      <span class="k">yield</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="s1">&#39;Rocko&#39;</span><span class="p">,</span><span class="s1">&#39;Spunky&#39;</span><span class="p">,</span><span class="s1">&#39;Heffer&#39;</span><span class="p">,</span><span class="s1">&#39;Filburt&#39;</span><span class="o">].</span><span class="n">monkey_each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#=&gt; Rocko!</span>
</span><span class='line'><span class="c1">#=&gt; Spunky!</span>
</span><span class='line'><span class="c1">#=&gt; Heffer!</span>
</span><span class='line'><span class="c1">#=&gt; Filburt!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Everybody uses Blocks. They are fundamental building_blocks_ of Ruby programing.</p>

<h2>Procs</h2>

<p>Procs (short for “procedures”) are like Blocks with names. Formally, Procs are “anonymous functions” that can be represented as an object. Procs can be saved with a variable and reused throughout the program.[2] Unlike Blocks, Procs are actual objects constructed through use of the <code>Proc</code> class.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">square_proc</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">num</span><span class="o">**</span><span class="mi">2</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, Procs respond to <code>.call</code> instead of <code>yield</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Array</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">each_with_proc</span><span class="p">(</span><span class="nb">proc</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">proc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">each_with_proc</span><span class="p">(</span><span class="n">bang_proc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#=&gt; 4</span>
</span><span class='line'><span class="c1">#=&gt; 9</span>
</span><span class='line'><span class="c1">#=&gt; 16</span>
</span><span class='line'><span class="c1">#=&gt; 25</span>
</span></code></pre></td></tr></table></div></figure>


<p>Procs help your programs stay DRY. If you catch yourself using the same Block logic repeatedly within your application then store that logic in Proc to avoid repetition.</p>

<h2>Lambdas</h2>

<p>Lambdas are basically strict Procs with different  <code>return</code> behavior. Both Lambdas and Procs are instances of the <code>Proc</code> class and both act like “anonymous functions”, however, Lambdas respect “arity” (a fancy way of saying that they will break if given an incorrect number of arguments, just like methods).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">square_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">num</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">square_lambda</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>    <span class="c1">#=&gt; 256</span>
</span><span class='line'><span class="n">square_proc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>    <span class="c1">#=&gt; 256</span>
</span><span class='line'><span class="n">square_lambda</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="c1">#=&gt; wrong number of arguments (2 for 1) (ArgumentError)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Alternatively, Lambdas can be created in what may be the most bad-ass name for obscure syntax — &ldquo;stabby lambda&rdquo;:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">cube_lambda</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">num</span><span class="p">){</span> <span class="nb">puts</span> <span class="n">num</span><span class="o">**</span><span class="mi">3</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cube_lambda</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>     <span class="c1">#=&gt; 729</span>
</span></code></pre></td></tr></table></div></figure>


<p>Lambdas and Procs also handle <code>return</code> statements differently. Procs interpret the <code>return</code> within the scope that called the proc. Lambdas, on the other hand, interpret the <code>return</code> within the scope of the lambda (exactly the same way a method would handle a <code>return</code>). This is might seem like an esoteric difference but can easily cause some problems.[3]</p>

<p>Ultimately, choosing between Lambdas and Procs really depends on preference. Both are perfect for encapsulating and storing code.</p>

<h2>Conclusion</h2>

<p><img class="center" src="http://walterbm.github.io/images/lost_control_of_my_life.gif" width="500" height="250"></p>

<h3>References &amp; Notes</h3>

<ul>
<li>[1] <a href="https://en.wikipedia.org/wiki/Closurer">Wikipedia - Closures</a></li>
<li>[2] <a href="http://ruby-doc.org/core-2.2.2/Proc.html">Official Ruby Documentation (2.2.0) for the Proc class</a></li>
<li>[3] <a href="http://www.reactive.io/tips/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/">Reactive.IO has an excellent guide on blocks, procs, lambdas, and methods that covers the implication of the varying treatment of return</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struct Instruct]]></title>
    <link href="http://walterbm.github.io/blog/2015/06/25/struct-instruct/"/>
    <updated>2015-06-25T01:03:56-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/06/25/struct-instruct</id>
    <content type="html"><![CDATA[<p>Ruby is an amazingly flexible language. For almost every need Ruby provides the tools to craft an elegant and precise solution. Within Ruby is a digital toolshed powerful enough to build massive web application and precise enough to be wielded as a scalpel. Among the many tools available are <code>Struct</code>s.</p>

<h2>What are Structs?</h2>

<p>Despite their archaic name, Structs are simple and very useful. Structs provide a convenient way to bundle a few attributes together without having to explicitly write a class.[1] Basically, Structs are mini-classes with implicit data accessor methods. A Struct can serve as an elegant way to compartmentalize data within a class or serve as a way to build simple data structures without the overhead of a full-grown class.</p>

<h2>How to use a Struct</h2>

<p>Struct construction in Ruby is fairly simple.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Subway</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:line</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Generally a Struct is manipulated by calling methods the same way a class or other similar object would be used.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">stop</span> <span class="o">=</span> <span class="no">Subway</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;Grand Central&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="n">stop</span><span class="o">.</span><span class="n">name</span>             <span class="c1">#=&gt; &quot;Grand Central&quot;</span>
</span><span class='line'><span class="n">stop</span><span class="o">.</span><span class="n">line</span>             <span class="c1">#=&gt; 5</span>
</span><span class='line'>
</span><span class='line'><span class="n">stop</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="mi">4</span>
</span><span class='line'><span class="n">stop</span><span class="o">.</span><span class="n">line</span>             <span class="c1">#=&gt; 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, the strange powers of a Struct allow it to also be used  in a hash-like manner. Through this interface symbols and strings can be used interchangeably as keys.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">stop</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>           <span class="c1">#=&gt; &quot;Grand Central&quot;</span>
</span><span class='line'><span class="n">stop</span><span class="o">[</span><span class="s2">&quot;line&quot;</span><span class="o">]</span>          <span class="c1">#=&gt; 4</span>
</span><span class='line'>
</span><span class='line'><span class="n">stop</span><span class="o">[</span><span class="s2">&quot;name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;23rd Street&quot;</span>
</span><span class='line'><span class="n">stop</span><span class="o">[</span><span class="ss">:line</span><span class="o">]</span> <span class="o">=</span> <span class="mi">6</span>
</span></code></pre></td></tr></table></div></figure>


<p>But wait, that’s not all. For the low price of $0.00 Structs also allow you to define custom Struct methods.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Email</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span><span class="ss">:domain</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">email</span><span class="o">|</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">address</span>
</span><span class='line'>    <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="err">‘</span> <span class="err">‘</span><span class="p">,</span><span class="err">’</span><span class="n">_</span><span class="err">’</span><span class="p">)</span><span class="si">}</span><span class="s2">@</span><span class="si">#{</span><span class="n">domain</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">email_account</span> <span class="o">=</span> <span class="no">Email</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;walter beller morales&quot;</span><span class="p">,</span><span class="s2">&quot;arpanet.com&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">email_account</span><span class="o">.</span><span class="n">address</span> <span class="c1">#=&gt; &quot;walter_beller_morales@arpanet.com&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Truly, Structs are a strange and powerful beast.</p>

<p>This short overview only covers the fundamentals. Structs provide much more functionality including value-equality and access to all the enumerable methods.[2]</p>

<h2>Why use a Struct?</h2>

<p>Structs are ideal for following the guiding mantra of object-oriented design: the <strong>single responsibility principal</strong>. A Struct can be used within classes to normalize the internal data structure or to avoid redundancies. An ordinary class would need superfluous attribute readers and writers before it could replicate the functionality of a Struct.</p>

<p>Of course, Structs are not the solution to every problem. Every tool has its purpose. Structs create public accessors (readers and writers) that could pollute the scope if not managed carefully. Structs are also indadequate when the data structure needs to be flexible since a Struct instance will not accept data that was not explicitly accounted for in the constructor.</p>

<p>But generally, for simple data containers, Structs are preferable over hashes. Structs are faster, carry less overhead, only accept a specific data structure, and are much more powerful thanks to customs methods.[3]</p>

<h2><em>I wanna’a go fast</em></h2>

<p>Structs can also be through of as a hybrid  between classes and hashes. This hybird nature has given them quite a speed advantage over ordinary hashes. For those with the need for speed I set-up a small drag race experiment to test the speed of a Struct vs. a Hash.[4]</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="err">‘</span><span class="n">benchmark</span><span class="err">’</span>
</span><span class='line'><span class="kp">include</span> <span class="no">Benchmark</span>
</span><span class='line'><span class="no">COUNT</span> <span class="o">=</span> <span class="mi">10_000_000</span>
</span><span class='line'>
</span><span class='line'><span class="no">Benchmark</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="no">CAPTION</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="no">FORMAT</span><span class="p">,</span> <span class="err">“</span><span class="o">%</span> <span class="ss">difference</span><span class="p">:</span><span class="err">”</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
</span><span class='line'>  <span class="n">hash_test</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="err">“</span><span class="nb">hash</span><span class="p">:</span><span class="err">”</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="no">COUNT</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">first_programer</span> <span class="o">=</span> <span class="p">{</span><span class="ss">first_name</span><span class="p">:</span> <span class="err">‘</span><span class="n">ada</span><span class="err">’</span><span class="p">,</span> <span class="ss">last_email</span><span class="p">:</span> <span class="err">‘</span><span class="n">lovelace</span><span class="err">’</span><span class="p">}</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">struct_test</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="err">“</span><span class="ss">struct</span><span class="p">:</span><span class="err">”</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="no">Programer</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span><span class="p">)</span>
</span><span class='line'>    <span class="no">COUNT</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">first_programer</span> <span class="o">=</span> <span class="no">Programer</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="err">‘</span><span class="n">ada</span><span class="err">’</span><span class="p">,</span><span class="err">’</span><span class="n">lovelace</span><span class="err">’</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="o">[</span><span class="p">((</span><span class="n">hash_test</span><span class="o">-</span><span class="n">struct_test</span><span class="p">)</span><span class="o">/</span><span class="n">hash_test</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'>                  <span class="err">user</span>     <span class="err">system</span>      <span class="err">total</span>        <span class="err">real</span>
</span><span class='line'><span class="err">hash:</span>             <span class="mf">8.100000</span>   <span class="mf">0.020000</span>   <span class="mf">8.120000</span>    <span class="err">(</span><span class="mf">8.138051</span><span class="err">)</span>
</span><span class='line'><span class="err">struct:</span>           <span class="mf">4.270000</span>   <span class="mf">0.010000</span>   <span class="mf">4.280000</span>    <span class="err">(</span><span class="mf">4.285140</span><span class="err">)</span>
</span><span class='line'><span class="err">%</span> <span class="err">difference:</span>     <span class="mf">47.283951</span>  <span class="mf">50.000000</span>        <span class="err">NaN</span>   <span class="err">(</span><span class="mf">47.344402</span><span class="err">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Over 10 million iterations, a Struct is roughly 47% faster than a hash. Not bad for a relatively unknown Ruby object.</p>

<h2>Deconstructing Ruby</h2>

<p>Ruby inherent simplicity and elegance is made possible by the immense variety of tools the language provides. Structs are only a small tool in the Ruby war chest but a tool you can now confidently wield.</p>

<p>One of the great joys of learning to code is gaining an intimate understanding of your chosen programing language and all the tools it provides. Just like a bicycle or a pen, deeply learning  a pogroming language a can make that language feel less like foreign tool and more like an extension of the mind.</p>

<h3>References &amp; Notes</h3>

<ul>
<li>[1] Metz, Sandi (2012-09-05). Practical Object-Oriented Design in Ruby: An Agile Primer (Addison-Wesley Professional Ruby Series). Pearson Education. Kindle Edition.</li>
<li>[2] <a href="http://ruby-doc.org/core-2.2.0/Struct.html">Official Ruby Documentation (2.2.0) for the Struct class</a></li>
<li>[3] <a href="http://stephaniehoh.github.io/blog/2013/12/28/the-ruby-struct-class/">Stephanie Oh (another great Flatiron School grad) wrote up a great overview of the Struct Class.</a></li>
<li>[4] The comparison uses Ruby’s Benchmark library. I decided to set up the experiment to analyze the actual construction of an instance. The hash test builds an instance of the Hash class and the struct test build an instance of the specific Struct. This seems to mostly closely simulate normal use. An alternate setup iterating over the actual Struct construction would drastically reduce the speed advantage of Structs.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Does .reduce(:+) Work?]]></title>
    <link href="http://walterbm.github.io/blog/2015/06/11/how-does-reduce-plus-work/"/>
    <updated>2015-06-11T02:12:20-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/06/11/how-does-reduce-plus-work</id>
    <content type="html"><![CDATA[<p>How do you sum up all the elements of an array in Ruby?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="ss">:+</span><span class="p">)</span> <span class="c1"># =&gt; 15</span>
</span></code></pre></td></tr></table></div></figure>


<p>That’s all you need. Simple and elegant. But how does this code actually work?</p>

<p>Unpacking the logic of this tiny line of code require understanding blocks, procs, and the hidden power of symbols.</p>

<h3>Breaking down .reduce</h3>

<p>Without understanding <code>.reduce(:+)</code> a beginner like myself might use <code>.reduce</code> in this familiar implementation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">element</span><span class="o">|</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">+</span> <span class="n">element</span>
</span><span class='line'><span class="k">end</span> <span class="c1"># =&gt; 15</span>
</span></code></pre></td></tr></table></div></figure>


<p>The process here is much easier to follow.</p>

<ol>
<li>the <code>[1,2,3,4,5]</code> array calls the <code>.reduce</code> method (or <code>.inject</code>, either method can be used interchangeably).</li>
<li>the <code>.reduce</code> method (part of the Enumerable module in Ruby) allows all the elements of any enumerator object (array, hash, etc) to be combined by applying the logic specified in the block (everything between <code>do</code> and <code>end</code>).</li>
<li>in the example above the block specifies that the elements should be added together through the logic in line 2: <code>sum  + element</code>.</li>
</ol>


<p>So we know Ruby is somehow converting the “plus symbol” into a complete block when <code>:+</code> is passed as an argument.</p>

<p>Usually the argument for a <code>.reduce</code> method sets the initial value for the sum. For example <code>.reduce(11)</code> would start the sum from 11. However, a close reading of the Ruby Docs — all of Ruby’s juicy secrets are in the documentation — reveals that the <code>.reduce</code> method also accepts <em>symbols</em> as arguments.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">starting_value_or_symbol</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">starting_value_or_symbol</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">Symbol</span>
</span><span class='line'>    <span class="c1"># convert symbol into a method block</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="c1"># regular reduce() process</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>When a symbol is passed as an argument then “each element in the collection will be passed to the named method.”[1] For our purposes the named method for the <code>:+</code> symbol is naturally the <code>.+</code> method.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">11</span><span class="o">.</span><span class="n">+</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="c1"># =&gt; 28</span>
</span></code></pre></td></tr></table></div></figure>


<p>This notation seems insane so lets create our own summation method to better illustrate the process call.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">first_number</span><span class="p">,</span> <span class="n">second_number</span><span class="p">)</span>
</span><span class='line'>  <span class="n">first_number</span> <span class="o">+</span> <span class="n">second_number</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>So passing a <em>symbol</em> to <code>.reduce</code> effectively calls the method with the same name as the symbol. This explains why <code>:-</code> and <code>:*</code> also work.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="ss">:-</span><span class="p">)</span> <span class="c1"># =&gt; -13</span>
</span><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">reduce</span><span class="p">(</span><span class="ss">:*</span><span class="p">)</span> <span class="c1"># =&gt; 120</span>
</span></code></pre></td></tr></table></div></figure>


<p>But this is still not quite reaching the magic of <code>.reduce(:+)</code>. The <code>.reduce</code> method calls on the <code>.+</code> method but how does the <em>symbol</em> <code>:+</code> lead to the <code>.+</code> method?</p>

<h3>The Secret Life of Objects</h3>

<p>Turns out that symbols in Ruby live a secret life. Remove the suit and glasses and ordinary symbols become powerful <strong>Procs</strong> and <strong>Methods</strong>[2]. Ruby’s <code>.to_proc</code> method automatically converts any symbol into proc and <code>method(string_or_symbol)</code> looks up methods matching the string or symbol passes as an argument. Looked-up methods and procs are used directly through the <code>.call</code> method.</p>

<p>So the hidden abstraction of the <code>.reduce</code> method goes through these steps:</p>

<ol>
<li>recognizes when a symbol is passed as an argument</li>
<li>converts the symbol into a proc</li>
<li>calls the proc on the elements of the enumerable.</li>
</ol>


<p>We can use another Enumerator method, like <code>.each</code>, to create an unnecessary code-sandwich that helps reveals the hidden conversion of symbols into procs and looked-up methods.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">symbol</span> <span class="o">=</span> <span class="ss">:+</span>
</span><span class='line'><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
</span><span class='line'>  <span class="n">proc_from_symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">to_proc</span>    <span class="c1"># converts :+ into a proc</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">=</span> <span class="n">proc_from_symbol</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>    <span class="c1"># calls the proc</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">sum</span> <span class="c1"># =&gt; 15</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or if we want to pass the <code>sum</code> method we created above.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">symbol</span> <span class="o">=</span> <span class="ss">:plus</span>  <span class="c1"># reference to a custom ‘plus’ method</span>
</span><span class='line'><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
</span><span class='line'>  <span class="n">lookup</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>  <span class="c1"># looks-up a method matching :plus</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">=</span> <span class="n">lookup</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># calls the matching method</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">sum</span> <span class="c1"># =&gt; 15</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Quick and Easy</h3>

<p>The mantra of the Ruby language is ‘quick and easy’ and <code>.reduce(:+)</code> is a brilliant line of code that perfectly encapsulates this mindset. Learning more about blocks, proc, and symbols unearths the incredibly power and flexibility of Ruby.</p>

<ul>
<li>[1] <a href="http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-reduce">Official Ruby Documentation (2.2.0) for the reduce method</a></li>
<li>[2] <a href="http://awaxman11.github.io/blog/2013/08/05/what-is-the-difference-between-a-block/">Adam Waxman (fellow Flatiron School grad) wrote a great post on the differences between blocks, procs, and lambdas in Ruby</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post On Octopress]]></title>
    <link href="http://walterbm.github.io/blog/2015/06/02/my-first-post-on-octopress/"/>
    <updated>2015-06-02T14:12:44-04:00</updated>
    <id>http://walterbm.github.io/blog/2015/06/02/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>First day at The Flatiron School.</p>
]]></content>
  </entry>
  
</feed>
